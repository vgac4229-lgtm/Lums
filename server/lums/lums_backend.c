#include "lums.h"
#include "electromechanical.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <unistd.h>

// Moteur global LUMS
static LUMSBackend g_backend;
static int g_backend_initialized = 0;

// Structure backend LUMS compl√®te
typedef struct {
    ElectromechanicalEngine electro_engine;
    VoraxEngine* vorax_engine;
    uint64_t total_computations;
    uint64_t energy_consumed;
    double computation_time_ms;
    char status_message[256];
    LUMRegister registers[16];
    LUMMemoryBlock memory_blocks[64];
    uint8_t active_memory_blocks;
} LUMSBackend;

// Registres LUM pour calculs r√©els
typedef struct {
    uint64_t lum_state;
    uint8_t lum_count;
    uint8_t is_presence_dominant;
    uint64_t last_operation_tick;
} LUMRegister;

// Blocs m√©moire LUM
typedef struct {
    uint64_t data[8];  // 8x64 bits = 512 bits par bloc
    uint8_t used_bits;
    uint8_t conservation_checksum;
    uint64_t creation_timestamp;
} LUMMemoryBlock;

// Initialisation backend LUMS complet
int lums_backend_init(void) {
    if (g_backend_initialized) {
        return 0; // D√©j√† initialis√©
    }

    printf("üîß Initialisation backend LUMS/VORAX...\n");

    // Reset structure
    memset(&g_backend, 0, sizeof(LUMSBackend));

    // Initialisation moteur √©lectrom√©canique
    if (electromechanical_engine_init(&g_backend.electro_engine) != 0) {
        strcpy(g_backend.status_message, "√âchec init moteur √©lectrom√©canique");
        return -1;
    }

    // Initialisation moteur VORAX
    g_backend.vorax_engine = create_vorax_engine();
    if (!g_backend.vorax_engine) {
        strcpy(g_backend.status_message, "√âchec init moteur VORAX");
        return -2;
    }

    // Initialisation registres
    for (int i = 0; i < 16; i++) {
        g_backend.registers[i].lum_state = 0;
        g_backend.registers[i].lum_count = 0;
        g_backend.registers[i].is_presence_dominant = 0;
        g_backend.registers[i].last_operation_tick = 0;
    }

    // Initialisation blocs m√©moire
    for (int i = 0; i < 64; i++) {
        memset(g_backend.memory_blocks[i].data, 0, sizeof(g_backend.memory_blocks[i].data));
        g_backend.memory_blocks[i].used_bits = 0;
        g_backend.memory_blocks[i].conservation_checksum = 0;
        g_backend.memory_blocks[i].creation_timestamp = 0;
    }

    g_backend.active_memory_blocks = 0;
    g_backend.total_computations = 0;
    g_backend.energy_consumed = 0;
    g_backend.computation_time_ms = 0.0;
    strcpy(g_backend.status_message, "Backend LUMS initialis√© avec succ√®s");

    g_backend_initialized = 1;
    printf("‚úì Backend LUMS initialis√©\n");
    return 0;
}

// Nettoyage backend
void lums_backend_cleanup(void) {
    if (!g_backend_initialized) return;

    printf("üßπ Nettoyage backend LUMS...\n");

    if (g_backend.vorax_engine) {
        free_vorax_engine(g_backend.vorax_engine);
        g_backend.vorax_engine = NULL;
    }

    electromechanical_engine_cleanup(&g_backend.electro_engine);
    g_backend_initialized = 0;

    printf("‚úì Backend LUMS nettoy√©\n");
}

// Calcul de fusion r√©el avec conservation LUM
int lums_compute_fusion_real(uint64_t lum_a, uint64_t lum_b, uint64_t* result) {
    if (!g_backend_initialized || !result) return -1;

    struct timespec start, end;
    clock_gettime(CLOCK_MONOTONIC, &start);

    // Conservation des LUMs : fusion = OR logique avec validation
    int count_a = __builtin_popcountll(lum_a);
    int count_b = __builtin_popcountll(lum_b);

    *result = lum_a | lum_b;  // Fusion par OR logique
    int count_result = __builtin_popcountll(*result);

    // Validation conservation (peut √™tre <= somme car overlaps)
    if (count_result > count_a + count_b) {
        return -2; // Violation conservation
    }

    // Simulation √©lectrom√©canique
    electromechanical_operate_relay(&g_backend.electro_engine, 0, 1);
    electromechanical_operate_relay(&g_backend.electro_engine, 1, 1);

    // Mise √† jour m√©triques
    clock_gettime(CLOCK_MONOTONIC, &end);
    double time_ms = (end.tv_sec - start.tv_sec) * 1000.0 + 
                     (end.tv_nsec - start.tv_nsec) / 1000000.0;

    g_backend.total_computations++;
    g_backend.energy_consumed += 15; // 15 unit√©s par fusion
    g_backend.computation_time_ms += time_ms;

    snprintf(g_backend.status_message, sizeof(g_backend.status_message),
             "Fusion: %d+%d LUMs ‚Üí %d LUMs (%.2fms)",
             count_a, count_b, count_result, time_ms);

    return 0;
}

// Calcul de division r√©el avec conservation
int lums_compute_split_real(uint64_t lum_input, int zones, uint64_t* results) {
    if (!g_backend_initialized || !results || zones <= 0) return -1;

    struct timespec start, end;
    clock_gettime(CLOCK_MONOTONIC, &start);

    int total_lums = __builtin_popcountll(lum_input);
    int lums_per_zone = total_lums / zones;
    int remainder = total_lums % zones;

    // Distribution √©quitable des LUMs
    uint64_t mask = 1ULL;
    int current_zone = 0;
    int lums_in_current = 0;

    for (int i = 0; i < zones; i++) {
        results[i] = 0;
    }

    for (int bit = 0; bit < 64 && current_zone < zones; bit++) {
        if (lum_input & (1ULL << bit)) {
            results[current_zone] |= (1ULL << lums_in_current);
            lums_in_current++;

            int target_for_zone = lums_per_zone + (current_zone < remainder ? 1 : 0);
            if (lums_in_current >= target_for_zone) {
                current_zone++;
                lums_in_current = 0;
            }
        }
    }

    // Validation conservation
    int total_output = 0;
    for (int i = 0; i < zones; i++) {
        total_output += __builtin_popcountll(results[i]);
    }

    if (total_output != total_lums) {
        return -2; // Violation conservation
    }

    // Mise √† jour m√©triques
    clock_gettime(CLOCK_MONOTONIC, &end);
    double time_ms = (end.tv_sec - start.tv_sec) * 1000.0 + 
                     (end.tv_nsec - start.tv_nsec) / 1000000.0;

    g_backend.total_computations++;
    g_backend.energy_consumed += 10 * zones;
    g_backend.computation_time_ms += time_ms;

    snprintf(g_backend.status_message, sizeof(g_backend.status_message),
             "Split: %d LUMs ‚Üí %d zones (%.2fms)",
             total_lums, zones, time_ms);

    return 0;
}

// Calcul de cycle r√©el
int lums_compute_cycle_real(uint64_t lum_input, int modulo, uint64_t* result) {
    if (!g_backend_initialized || !result || modulo <= 0) return -1;

    struct timespec start, end;
    clock_gettime(CLOCK_MONOTONIC, &start);

    int input_count = __builtin_popcountll(lum_input);
    int result_count = input_count % modulo;

    if (result_count == 0) {
        *result = 1; // Au moins 1 LUM pr√©sent
        result_count = 1;
    } else {
        // Conservation des premiers bits
        *result = lum_input & ((1ULL << result_count) - 1);
    }

    // Simulation √©lectrom√©canique cyclique
    for (int i = 0; i < modulo; i++) {
        electromechanical_operate_relay(&g_backend.electro_engine, i % 8, i % 2);
    }

    // Mise √† jour m√©triques
    clock_gettime(CLOCK_MONOTONIC, &end);
    double time_ms = (end.tv_sec - start.tv_sec) * 1000.0 + 
                     (end.tv_nsec - start.tv_nsec) / 1000000.0;

    g_backend.total_computations++;
    g_backend.energy_consumed += 5 * modulo;
    g_backend.computation_time_ms += time_ms;

    snprintf(g_backend.status_message, sizeof(g_backend.status_message),
             "Cycle: %d LUMs mod %d ‚Üí %d LUMs (%.2fms)",
             input_count, modulo, result_count, time_ms);

    return 0;
}

// Stockage m√©moire avec checksum
int lums_store_memory_real(uint64_t lum_data, int slot_id) {
    if (!g_backend_initialized || slot_id < 0 || slot_id >= 64) return -1;

    LUMMemoryBlock* block = &g_backend.memory_blocks[slot_id];

    // Stockage donn√©es
    block->data[0] = lum_data;
    for (int i = 1; i < 8; i++) {
        block->data[i] = 0;
    }

    block->used_bits = __builtin_popcountll(lum_data);
    block->creation_timestamp = time(NULL);

    // Calcul checksum CRC32 simplifi√©
    uint32_t checksum = 0;
    for (int i = 0; i < 8; i++) {
        checksum ^= (uint32_t)(block->data[i] & 0xFFFFFFFF);
        checksum ^= (uint32_t)((block->data[i] >> 32) & 0xFFFFFFFF);
    }
    block->conservation_checksum = (uint8_t)(checksum & 0xFF);

    if (slot_id >= g_backend.active_memory_blocks) {
        g_backend.active_memory_blocks = slot_id + 1;
    }

    return 0;
}

// R√©cup√©ration m√©moire avec validation
int lums_retrieve_memory_real(int slot_id, uint64_t* result) {
    if (!g_backend_initialized || !result || slot_id < 0 || slot_id >= 64) return -1;

    LUMMemoryBlock* block = &g_backend.memory_blocks[slot_id];

    if (block->used_bits == 0) {
        return -2; // Slot vide
    }

    // Validation checksum
    uint32_t checksum = 0;
    for (int i = 0; i < 8; i++) {
        checksum ^= (uint32_t)(block->data[i] & 0xFFFFFFFF);
        checksum ^= (uint32_t)((block->data[i] >> 32) & 0xFFFFFFFF);
    }

    if ((uint8_t)(checksum & 0xFF) != block->conservation_checksum) {
        return -3; // Corruption d√©tect√©e
    }

    *result = block->data[0];
    return 0;
}

// Calcul sqrt via m√©thode Newton avec LUMs
double lums_compute_sqrt_via_lums(double input) {
    if (!g_backend_initialized || input < 0) return -1.0;

    struct timespec start, end;
    clock_gettime(CLOCK_MONOTONIC, &start);

    if (input == 0.0) return 0.0;
    if (input == 1.0) return 1.0;

    // M√©thode de Newton: x_{n+1} = (x_n + input/x_n) / 2
    double x = input / 2.0;  // Estimation initiale
    double precision = 1e-10;
    int max_iterations = 50;

    for (int i = 0; i < max_iterations; i++) {
        double x_new = (x + input / x) / 2.0;

        // Simulation LUM pour chaque it√©ration
        uint64_t lum_state = (uint64_t)(x_new * 1000000) & 0xFFFFFFFF;
        electromechanical_operate_relay(&g_backend.electro_engine, 
                                      i % 8, 
                                      __builtin_popcount((uint32_t)lum_state) % 2);

        if (fabs(x_new - x) < precision) {
            x = x_new;
            break;
        }
        x = x_new;
    }

    // Mise √† jour m√©triques
    clock_gettime(CLOCK_MONOTONIC, &end);
    double time_ms = (end.tv_sec - start.tv_sec) * 1000.0 + 
                     (end.tv_nsec - start.tv_nsec) / 1000000.0;

    g_backend.total_computations++;
    g_backend.energy_consumed += 25;
    g_backend.computation_time_ms += time_ms;

    return x;
}

// Test primalit√© via division LUM
int lums_test_prime_real(int number) {
    if (!g_backend_initialized || number < 2) return 0;

    struct timespec start, end;
    clock_gettime(CLOCK_MONOTONIC, &start);

    if (number == 2) return 1;
    if (number % 2 == 0) return 0;

    // Test division jusqu'√† ‚àönumber
    int sqrt_n = (int)sqrt(number);
    for (int i = 3; i <= sqrt_n; i += 2) {
        if (number % i == 0) {
            // Simulation LUM pour division
            uint64_t lum_div = ((uint64_t)number << 16) | i;
            electromechanical_operate_relay(&g_backend.electro_engine, 
                                          i % 8, 
                                          __builtin_popcountll(lum_div) % 2);

            clock_gettime(CLOCK_MONOTONIC, &end);
            double time_ms = (end.tv_sec - start.tv_sec) * 1000.0 + 
                             (end.tv_nsec - start.tv_nsec) / 1000000.0;

            g_backend.total_computations++;
            g_backend.energy_consumed += 8;
            g_backend.computation_time_ms += time_ms;

            return 0; // Non premier
        }
    }

    // Mise √† jour m√©triques pour nombre premier
    clock_gettime(CLOCK_MONOTONIC, &end);
    double time_ms = (end.tv_sec - start.tv_sec) * 1000.0 + 
                     (end.tv_nsec - start.tv_nsec) / 1000000.0;

    g_backend.total_computations++;
    g_backend.energy_consumed += 12;
    g_backend.computation_time_ms += time_ms;

    return 1; // Premier
}

// G√©n√©ration Fibonacci avec LUMs
int lums_generate_fibonacci_real(int count, uint64_t* sequence) {
    if (!g_backend_initialized || !sequence || count <= 0) return -1;

    struct timespec start, end;
    clock_gettime(CLOCK_MONOTONIC, &start);

    if (count >= 1) sequence[0] = 0;
    if (count >= 2) sequence[1] = 1;

    for (int i = 2; i < count; i++) {
        sequence[i] = sequence[i-1] + sequence[i-2];

        // Simulation LUM pour chaque nombre Fibonacci
        electromechanical_operate_relay(&g_backend.electro_engine, 
                                      i % 8, 
                                      __builtin_popcountll(sequence[i]) % 2);

        // Protection overflow
        if (sequence[i] < sequence[i-1]) {
            return -2; // Overflow d√©tect√©
        }
    }

    // Mise √† jour m√©triques
    clock_gettime(CLOCK_MONOTONIC, &end);
    double time_ms = (end.tv_sec - start.tv_sec) * 1000.0 + 
                     (end.tv_nsec - start.tv_nsec) / 1000000.0;

    g_backend.total_computations++;
    g_backend.energy_consumed += count * 3;
    g_backend.computation_time_ms += time_ms;

    return 0;
}

// Accesseurs pour m√©triques
uint64_t lums_backend_get_total_computations(void) {
    return g_backend_initialized ? g_backend.total_computations : 0;
}

uint64_t lums_backend_get_energy_consumed(void) {
    return g_backend_initialized ? g_backend.energy_consumed : 0;
}

const char* lums_backend_get_status(void) {
    return g_backend_initialized ? g_backend.status_message : "Backend non initialis√©";
}

// Rapport d'√©tat backend complet
void lums_backend_status_report(void) {
    if (!g_backend_initialized) {
        printf("‚ùå Backend LUMS non initialis√©\n");
        return;
    }

    printf("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                    RAPPORT BACKEND LUMS                   ‚ïë\n");
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");
    printf("‚ïë Computations totales: %8lu                             ‚ïë\n", g_backend.total_computations);
    printf("‚ïë √ânergie consomm√©e   : %8lu unit√©s                      ‚ïë\n", g_backend.energy_consumed);
    printf("‚ïë Temps total         : %8.2f ms                          ‚ïë\n", g_backend.computation_time_ms);
    printf("‚ïë Blocs m√©moire actifs: %8d/64                           ‚ïë\n", g_backend.active_memory_blocks);

    if (g_backend.total_computations > 0) {
        double avg_time = g_backend.computation_time_ms / g_backend.total_computations;
        double avg_energy = (double)g_backend.energy_consumed / g_backend.total_computations;

        printf("‚ïë Temps/op√©ration    : %8.3f ms                           ‚ïë\n", avg_time);
        printf("‚ïë √ânergie/op√©ration  : %8.2f unit√©s                      ‚ïë\n", avg_energy);
    }

    printf("‚ïë Status: %-50s ‚ïë\n", g_backend.status_message);
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
}

// Test complet du backend
int lums_backend_comprehensive_test(void) {
    printf("\n=== TEST COMPLET BACKEND LUMS ===\n");

    // Test 1: Fusion
    uint64_t test1_a = 0b11010;  // 3 LUMs
    uint64_t test1_b = 0b1100;   // 2 LUMs
    uint64_t fusion_result;

    if (lums_compute_fusion_real(test1_a, test1_b, &fusion_result) == 0) {
        printf("‚úì Test fusion r√©ussi\n");
    } else {
        printf("‚úó Test fusion √©chou√©\n");
        return -1;
    }

    // Test 2: Division
    uint64_t split_results[4];
    if (lums_compute_split_real(fusion_result, 3, split_results) == 0) {
        printf("‚úì Test division r√©ussi\n");
    } else {
        printf("‚úó Test division √©chou√©\n");
        return -2;
    }

    // Test 3: Cycle
    uint64_t cycle_result;
    if (lums_compute_cycle_real(fusion_result, 7, &cycle_result) == 0) {
        printf("‚úì Test cycle r√©ussi\n");
    } else {
        printf("‚úó Test cycle √©chou√©\n");
        return -3;
    }

    // Test 4: Stockage m√©moire
    if (lums_store_memory_real(cycle_result, 5) == 0) {
        printf("‚úì Test stockage r√©ussi\n");
    } else {
        printf("‚úó Test stockage √©chou√©\n");
        return -4;
    }

    // Test 5: R√©cup√©ration m√©moire
    uint64_t retrieved_data;
    if (lums_retrieve_memory_real(5, &retrieved_data) == 0) {
        printf("‚úì Test r√©cup√©ration r√©ussi\n");
    } else {
        printf("‚úó Test r√©cup√©ration √©chou√©\n");
        return -5;
    }

    // Test 6: Calcul math√©matique
    double sqrt_result = lums_compute_sqrt_via_lums(16.0);
    if (fabs(sqrt_result - 4.0) < 0.001) {
        printf("‚úì Test calcul ‚àö16 = %.6f r√©ussi\n", sqrt_result);
    } else {
        printf("‚úó Test calcul ‚àö16 √©chou√©: %.6f\n", sqrt_result);
        return -6;
    }

    // Test 7: Test primalit√©
    if (lums_test_prime_real(17) == 1) {
        printf("‚úì Test primalit√© 17 r√©ussi\n");
    } else {
        printf("‚úó Test primalit√© 17 √©chou√©\n");
        return -7;
    }

    // Test 8: Fibonacci
    uint64_t fib_results[10];
    if (lums_generate_fibonacci_real(8, fib_results) == 0) {
        printf("‚úì Test Fibonacci r√©ussi\n");
    } else {
        printf("‚úó Test Fibonacci √©chou√©\n");
        return -8;
    }

    lums_backend_status_report();
    printf("‚úÖ TOUS LES TESTS BACKEND R√âUSSIS\n\n");
    return 0;
}